{
  "api/RayGame.CollisionDetection.html": {
    "href": "api/RayGame.CollisionDetection.html",
    "title": "Class CollisionDetection",
    "keywords": "Class CollisionDetection Provides a method for collision detection between shapes. Inheritance object CollisionDetection Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame Assembly: RayGame.dll Syntax public static class CollisionDetection Remarks This is a Static class used internally to check the collision between Colliders in GameObjects.Primarily for internal use Methods | Edit this page View Source CheckCollision(Vector2[], Vector2[]) Checks if two shapes are colliding. Declaration public static bool CheckCollision(Vector2[] shape1, Vector2[] shape2) Parameters Type Name Description Vector2[] shape1 The first shape. Vector2[] shape2 The second shape. Returns Type Description bool True if the shapes are colliding, otherwise false."
  },
  "api/RayGame.Demo.Demo.html": {
    "href": "api/RayGame.Demo.Demo.html",
    "title": "Class Demo",
    "keywords": "Class Demo Inheritance object Demo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame.Demo Assembly: RayGame.dll Syntax public static class Demo Methods | Edit this page View Source Main() Declaration public static void Main()"
  },
  "api/RayGame.Demo.Manager.html": {
    "href": "api/RayGame.Demo.Manager.html",
    "title": "Class Manager",
    "keywords": "Class Manager Inheritance object Manager Implements IGameComponent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame.Demo Assembly: RayGame.dll Syntax public class Manager : IGameComponent Fields | Edit this page View Source PipeInstances Declaration public List<GameObject> PipeInstances Field Value Type Description List<GameObject> | Edit this page View Source Running Declaration public bool Running Field Value Type Description bool Properties | Edit this page View Source Container The container GameObject for this component. Declaration public GameObject Container { get; set; } Property Value Type Description GameObject | Edit this page View Source Instance Declaration public static Manager Instance { get; } Property Value Type Description Manager Methods | Edit this page View Source RestartGame() Declaration public void RestartGame() | Edit this page View Source SpawnObject() Declaration public void SpawnObject() | Edit this page View Source Start() Called when the component is Added. Declaration public void Start() | Edit this page View Source Update() Called every frame to update the component. Declaration public void Update() Implements IGameComponent"
  },
  "api/RayGame.Demo.bird.html": {
    "href": "api/RayGame.Demo.bird.html",
    "title": "Class Bird",
    "keywords": "Class Bird Inheritance object Bird Implements IGameComponent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame.Demo Assembly: RayGame.dll Syntax public class Bird : IGameComponent Properties | Edit this page View Source Container The container GameObject for this component. Declaration public GameObject Container { get; set; } Property Value Type Description GameObject Methods | Edit this page View Source Start() Called when the component is Added. Declaration public void Start() | Edit this page View Source Update() Called every frame to update the component. Declaration public void Update() Implements IGameComponent"
  },
  "api/RayGame.Demo.html": {
    "href": "api/RayGame.Demo.html",
    "title": "Namespace RayGame.Demo",
    "keywords": "Namespace RayGame.Demo Classes Bird Demo Manager"
  },
  "api/RayGame.Engine.html": {
    "href": "api/RayGame.Engine.html",
    "title": "Class Engine",
    "keywords": "Class Engine The main engine class that initializes and runs the game. Inheritance object Engine Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame Assembly: RayGame.dll Syntax public static class Engine Fields | Edit this page View Source random The Random Number Generator initiated with the Engine. Declaration public static Random random Field Value Type Description Random Properties | Edit this page View Source GAMETIME The value associated with the amount of milliseconds passed. Declaration public static long GAMETIME { get; } Property Value Type Description long Methods | Edit this page View Source CreateGameObject(string) Creates a new game object with the specified name. Declaration public static GameObject CreateGameObject(string name) Parameters Type Name Description string name The name of the game object. Returns Type Description GameObject The created game object. | Edit this page View Source CreateGameObject(string, Transform) Creates a new game object with the specified name and Transform>. Declaration public static GameObject CreateGameObject(string name, Transform transform) Parameters Type Name Description string name The name of the game object. Transform transform The transform of the game object. Returns Type Description GameObject The created game object. | Edit this page View Source CreateGameObject(string, Vector2, float, float) Creates a new game object with the specified name, position, angle, and scale. Declaration public static GameObject CreateGameObject(string name, Vector2 Position, float Angle, float Scale) Parameters Type Name Description string name The name of the game object. Vector2 Position The position of the game object. float Angle The angle of the game object. float Scale The scale of the game object. Returns Type Description GameObject The created game object. | Edit this page View Source DeleteGameObject(GameObject) Deletes the specified game object. Declaration public static void DeleteGameObject(GameObject Gobj) Parameters Type Name Description GameObject Gobj The game object to delete. | Edit this page View Source DisableColliderRendering() Disables rendering of colliders for all game objects. Look at GameObject for more detail. Declaration public static void DisableColliderRendering() | Edit this page View Source EnableColliderRendering() Enables rendering of colliders for all game objects. Look at GameObject for more detail. Declaration public static void EnableColliderRendering() | Edit this page View Source FindObjectByName(string) Finds a game object by its name. Declaration public static GameObject FindObjectByName(string name) Parameters Type Name Description string name The name of the game object. Returns Type Description GameObject The game object with the specified name, or null if not found. | Edit this page View Source FindObjectOfType<T>() Finds the first game object that has a component of the specified type. Declaration public static GameObject FindObjectOfType<T>() Returns Type Description GameObject The game object with the specified component, or null if not found. Type Parameters Name Description T The type of component to look for. | Edit this page View Source GetGameObjectCount() Gets the count of game objects currently in the engine. Declaration public static int GetGameObjectCount() Returns Type Description int The number of game objects. | Edit this page View Source INIT<T>() Initializes the game engine with a specified game component. That Custom Component is the entry point into using the Engine. Declaration public static void INIT<T>() where T : IGameComponent, new() Type Parameters Name Description T The type of game component to initialize."
  },
  "api/RayGame.GameObject.html": {
    "href": "api/RayGame.GameObject.html",
    "title": "Class GameObject",
    "keywords": "Class GameObject Represents a game object in the Scene. Inheritance object GameObject Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame Assembly: RayGame.dll Syntax public class GameObject Remarks The GameObjects are the building blocks of your scene. They contain a few fields that allow for adding logic and properties to make them functional. Fields | Edit this page View Source Colliders The List of Colliders attached to the GameObject. They are represented as a List of Mesh's. You can add Colliders directly. Declaration public List<Mesh> Colliders Field Value Type Description List<Mesh> | Edit this page View Source DEBUGCOLIDERS This is a property of the GameObject that determines what is to be rendered. If false, all the IRenderer's Update Method will be fired per frame. If true, then instead of the IRenderer's, the Colliders attached to your GameObject will be rendered. This is for debugging purposes. Declaration public bool DEBUGCOLIDERS Field Value Type Description bool | Edit this page View Source Name This is the Name Associated with the GameObject Declaration public string Name Field Value Type Description string | Edit this page View Source Transform This is the Transform attached to the GameObject. Declaration public Transform Transform Field Value Type Description Transform Methods | Edit this page View Source AddComponent<T>() Adds a component of the specified type to this game object. Declaration public T AddComponent<T>() where T : IGameComponent, new() Returns Type Description T The added component. Type Parameters Name Description T The type of component to add. | Edit this page View Source AddRenderer<T>() Adds a renderer of the specified type to this game object. Declaration public T AddRenderer<T>() where T : IRenderer, new() Returns Type Description T The added renderer. Type Parameters Name Description T The type of renderer to add. | Edit this page View Source DeleteAllRenderers() Deletes all renderers from this game object. Declaration public void DeleteAllRenderers() | Edit this page View Source DeleteComponent<T>() Deletes the first component of the specified type from this game object. Declaration public void DeleteComponent<T>() where T : IGameComponent Type Parameters Name Description T The type of component to delete. | Edit this page View Source DeleteObjectComponents() Deletes all components from this game object. Declaration public void DeleteObjectComponents() | Edit this page View Source DeleteRenderer<T>(int) Deletes a renderer of the specified type at the given index from this game object. Declaration public void DeleteRenderer<T>(int Index) where T : class, IRenderer Parameters Type Name Description int Index The index of the renderer to delete. Type Parameters Name Description T The type of renderer to delete. | Edit this page View Source GetComponentNameList(bool) Gets a list of the names of all components attached to this game object. Declaration public List<string> GetComponentNameList(bool Print) Parameters Type Name Description bool Print If true, prints the names to the console. Returns Type Description List<string> A list of component names. | Edit this page View Source GetComponent<T>() Gets the first component of the specified type attached to this game object. Declaration public T GetComponent<T>() Returns Type Description T The component if found, otherwise null. Type Parameters Name Description T The type of component to get. | Edit this page View Source GetRendererNameList(bool) Gets a list of the names of all renderers attached to this game object. Declaration public List<string> GetRendererNameList(bool Print) Parameters Type Name Description bool Print If true, prints the names to the console. Returns Type Description List<string> A list of renderer names. | Edit this page View Source GetRenderer<T>(int) Gets a renderer of the specified type at the given index from this game object. If the GameObject contains multiple types of renderers, then the index takes into account only the specified T Declaration public T GetRenderer<T>(int Index) where T : class, IRenderer Parameters Type Name Description int Index The index of the renderer to get. Returns Type Description T The renderer if found, otherwise null. Type Parameters Name Description T The type of renderer to get. | Edit this page View Source HasComponent<T>() Checks if this game object has a component of the specified type. Declaration public bool HasComponent<T>() where T : IGameComponent Returns Type Description bool True if the component is found, otherwise false. Type Parameters Name Description T The type of component to check for. | Edit this page View Source HasRenderer<T>() Checks if this game object has a renderer of the specified type. Declaration public bool HasRenderer<T>() where T : IRenderer Returns Type Description bool True if the renderer is found, otherwise false. Type Parameters Name Description T The type of renderer to check for. | Edit this page View Source IsColliding(GameObject) Checks if this game object is colliding with the specified target game object. Declaration public bool IsColliding(GameObject Target) Parameters Type Name Description GameObject Target The target game object to check for collisions with. Returns Type Description bool True if a collision is detected, otherwise false. | Edit this page View Source SetTransform(Transform) Sets the transform of this game object to the specified new transform. Declaration public void SetTransform(Transform newTransform) Parameters Type Name Description Transform newTransform The new transform to set. | Edit this page View Source ShiftComponent<T>(int) Shifts a component of the specified type by a given offset in the component list. Declaration public void ShiftComponent<T>(int offset) where T : IGameComponent Parameters Type Name Description int offset The offset by which to shift the component. Type Parameters Name Description T The type of component to shift. | Edit this page View Source ShiftRenderer<T>(int) Shifts a renderer of the specified type by a given offset in the renderer list. Declaration public void ShiftRenderer<T>(int offset) where T : IRenderer Parameters Type Name Description int offset The offset by which to shift the renderer. Type Parameters Name Description T The type of renderer to shift. | Edit this page View Source StartActions() The function that is called when the GameObject is Initiated. Not used in most cases. Primarily for internal use Declaration public void StartActions() | Edit this page View Source UpdateActions() This is the function that calls to update the state of the GameObject per frame.Primarily for internal use Declaration public void UpdateActions()"
  },
  "api/RayGame.IGameComponent.html": {
    "href": "api/RayGame.IGameComponent.html",
    "title": "Interface IGameComponent",
    "keywords": "Interface IGameComponent Interface for game components. Namespace: RayGame Assembly: RayGame.dll Syntax public interface IGameComponent Remarks Implement this interface to create custom game components. Each GameObject has a List of Components that it runs by itself. Hence, any class that implements IGameComponent, will be eligible to perform as a script attached to the Object. By This, It is possible to create Prefabs buy creating 1 class component that adds all the required components and modifications. Properties | Edit this page View Source Container The container GameObject for this component. Declaration GameObject Container { get; set; } Property Value Type Description GameObject Methods | Edit this page View Source Start() Called when the component is Added. Declaration void Start() | Edit this page View Source Update() Called every frame to update the component. Declaration void Update()"
  },
  "api/RayGame.IRenderer.html": {
    "href": "api/RayGame.IRenderer.html",
    "title": "Interface IRenderer",
    "keywords": "Interface IRenderer Interface for renderers. Namespace: RayGame Assembly: RayGame.dll Syntax public interface IRenderer Remarks This is interface is to be inherited by all Renderers, If you wish to make a custom renderer, then u can, but i would recommend sticking to the provided renderers. Primarily for internal use Properties | Edit this page View Source Container The container GameObject for this renderer. Any Actions that want to be performed to it, is does through this reference. Declaration GameObject Container { get; set; } Property Value Type Description GameObject Methods | Edit this page View Source Start() The Function Called when the Renderer is Added to an Object. Declaration void Start() | Edit this page View Source Update() Called every frame to update the renderer. Primarily holds code to render the content. Declaration void Update()"
  },
  "api/RayGame.Mesh.html": {
    "href": "api/RayGame.Mesh.html",
    "title": "Class Mesh",
    "keywords": "Class Mesh Represents a 2D mesh consisting of a collection of vertices. Inheritance object Mesh Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame Assembly: RayGame.dll Syntax public class Mesh Remarks A Mesh is a collection of Vertices that is used to display/render anything. It is always a closed loop. The Mesh also have functions that can edit it, however, be careful, as all modifications as permanent. It is Attached to a MeshRenderer to be viewed at the GameObject's Position. The vertices themselves are always represented in local space. Constructors | Edit this page View Source Mesh(Vector2[]) Initializes a new instance of the Mesh class with an array of vertices specified as Vector2. Declaration public Mesh(Vector2[] vertexArray) Parameters Type Name Description Vector2[] vertexArray An array of Vector2 representing the vertices of the mesh. | Edit this page View Source Mesh((float, float)[]) Initializes a new instance of the Mesh class with an array of vertices specified as tuples. Declaration public Mesh((float, float)[] vertexArray) Parameters Type Name Description (float, float)[] vertexArray An array of tuples representing the vertices of the mesh. Methods | Edit this page View Source AddVertex(Vector2) Adds a single vertex to the mesh. Declaration public void AddVertex(Vector2 vertex) Parameters Type Name Description Vector2 vertex The vertex to add to the mesh. | Edit this page View Source AddVertex((float, float)) Adds a single vertex to the mesh specified as a tuple. Declaration public void AddVertex((float, float) vertex) Parameters Type Name Description (float, float) vertex The vertex to add to the mesh. | Edit this page View Source AddVertices(Vector2[]) Adds an array of vertices to the mesh. Declaration public void AddVertices(Vector2[] vertexArray) Parameters Type Name Description Vector2[] vertexArray An array of Vector2 to add to the mesh. | Edit this page View Source AddVertices((float, float)[]) Adds an array of vertices to the mesh specified as tuples. Declaration public void AddVertices((float, float)[] vertexArray) Parameters Type Name Description (float, float)[] vertexArray An array of tuples representing the vertices to add to the mesh. | Edit this page View Source DeleteLastVertex() Deletes a Vertex from the last position. Declaration public void DeleteLastVertex() | Edit this page View Source DeleteVertex(int) Deletes a vertex at the specified index. Declaration public void DeleteVertex(int Index) Parameters Type Name Description int Index The index of the vertex to delete. | Edit this page View Source DeleteVertex((float, float)) Deletes a vertex that matches the specified point. Declaration public void DeleteVertex((float, float) point) Parameters Type Name Description (float, float) point The point representing the vertex to delete. | Edit this page View Source GetVertexArray() Gets the vertices of the mesh as an array. Declaration public Vector2[] GetVertexArray() Returns Type Description Vector2[] An array of Vector2 representing the vertices of the mesh. | Edit this page View Source InsertVertex(int, Vector2) Inserts a vertex at the specified index. Declaration public void InsertVertex(int Index, Vector2 Vertex) Parameters Type Name Description int Index The index at which to insert the vertex. Vector2 Vertex The vertex to insert. | Edit this page View Source RotateMesh(float) Rotates the entire mesh by the specified angle. Declaration public Mesh RotateMesh(float Angle) Parameters Type Name Description float Angle The angle in degrees by which to rotate the mesh. Returns Type Description Mesh The rotated mesh. | Edit this page View Source ScaleMesh(float) Scales the entire mesh by the specified scale factor. Declaration public Mesh ScaleMesh(float Scale) Parameters Type Name Description float Scale The scale factor by which to scale the mesh. Returns Type Description Mesh The scaled mesh. | Edit this page View Source ShiftMesh(Vector2) Shifts the entire mesh by the specified offset in Position. Declaration public Mesh ShiftMesh(Vector2 Offset) Parameters Type Name Description Vector2 Offset The offset by which to shift the mesh. Returns Type Description Mesh The shifted mesh. | Edit this page View Source ShiftMesh((float, float)) Shifts the entire mesh by the specified offset in Position. Declaration public Mesh ShiftMesh((float, float) Offset) Parameters Type Name Description (float, float) Offset The offset specified as a tuple by which to shift the mesh. Returns Type Description Mesh The shifted mesh."
  },
  "api/RayGame.MeshRenderer.html": {
    "href": "api/RayGame.MeshRenderer.html",
    "title": "Class MeshRenderer",
    "keywords": "Class MeshRenderer A Renderer that renders a Mesh associated with a GameObject. Inheritance object MeshRenderer Implements IRenderer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame Assembly: RayGame.dll Syntax public class MeshRenderer : IRenderer Properties | Edit this page View Source Container The Container is the reference to the GameObject it is connected to. Declaration public GameObject Container { get; set; } Property Value Type Description GameObject Methods | Edit this page View Source GetMesh() Gets the mesh being rendered. Declaration public Mesh GetMesh() Returns Type Description Mesh The Mesh being rendered. | Edit this page View Source SetMesh(Mesh) Sets the mesh to be rendered. Declaration public Mesh SetMesh(Mesh mesh) Parameters Type Name Description Mesh mesh The Mesh to set. Returns Type Description Mesh The Mesh that was set. | Edit this page View Source Start() Initializes the renderer. This method is called when the renderer is first added to a GameObject. Declaration public void Start() | Edit this page View Source Update() Updates the renderer. This method is called once per frame. Declaration public void Update() Implements IRenderer"
  },
  "api/RayGame.SpriteRenderer.html": {
    "href": "api/RayGame.SpriteRenderer.html",
    "title": "Class SpriteRenderer",
    "keywords": "Class SpriteRenderer Inheritance object SpriteRenderer Implements IRenderer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame Assembly: RayGame.dll Syntax public class SpriteRenderer : IRenderer Fields | Edit this page View Source transform Declaration public Transform transform Field Value Type Description Transform Properties | Edit this page View Source Container The Container is the reference to the GameObject it is connected to. Declaration public GameObject Container { get; set; } Property Value Type Description GameObject Methods | Edit this page View Source GetSprite() Retrieves the current sprite texture. Declaration public Texture2D GetSprite() Returns Type Description Texture2D The current Raylib_cs.Texture2D sprite. | Edit this page View Source SetSprite(Texture2D) Sets the sprite texture. Declaration public void SetSprite(Texture2D ImputSprite) Parameters Type Name Description Texture2D ImputSprite | Edit this page View Source Start() Initializes the renderer. This method is called when the renderer is first added to a GameObject. Declaration public void Start() | Edit this page View Source Update() Updates the renderer. This method is called once per frame. Declaration public void Update() Implements IRenderer"
  },
  "api/RayGame.Transform.html": {
    "href": "api/RayGame.Transform.html",
    "title": "Class Transform",
    "keywords": "Class Transform The class that holds all the transformation data for an object Inheritance object Transform Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RayGame Assembly: RayGame.dll Syntax public class Transform Remarks A Class that is used to represent the Position, Rotation and Scale of an object. This class super-imposes its properties onto vertices per frame, which means that any object containing this class can enact global transformations within that GameObject. By default, any transformations does on the object should be done through its Transform. Constructors | Edit this page View Source Transform() Initializes a new instance of the Transform class with default values. Position being (0,0). Rotation being 0. Scale being 1. Declaration public Transform() | Edit this page View Source Transform(Vector2, float, float) Initializes a new instance of the Transform class with specified position, rotation, and scale. Declaration public Transform(Vector2 pos, float ang, float sc) Parameters Type Name Description Vector2 pos The position of the transform. float ang The rotation of the transform in degrees. float sc The scale of the transform. Fields | Edit this page View Source Position The position of the transform as a Vector2. Declaration public Vector2 Position Field Value Type Description Vector2 | Edit this page View Source Scale The Scale of the transform as a Float. Declaration public float Scale Field Value Type Description float Methods | Edit this page View Source ApplyTransform(Vector2[]) Applies the transform to an array of vertices. Applies that transforms onto the Vertices of a Mesh's Vertex Array. Primarily used internally in the Engine. Declaration public Vector2[] ApplyTransform(Vector2[] VertexArray) Parameters Type Name Description Vector2[] VertexArray The array of vertices to transform. Returns Type Description Vector2[] The transformed array of vertices. | Edit this page View Source GetRotation() Gets the rotation of the transform. Declaration public float GetRotation() Returns Type Description float The rotation in returned as Degrees. | Edit this page View Source Rotate(float) Rotates the transform by the specified angle. Takes an Angle in degrees, and stores them internally as radians. Declaration public void Rotate(float Angle) Parameters Type Name Description float Angle The angle in degrees. | Edit this page View Source SetRotation(float) Sets the rotation of the transform to the specified angle. Takes an Angle in degrees, and stores them internally as radians. Declaration public void SetRotation(float Angle) Parameters Type Name Description float Angle The angle in degrees. | Edit this page View Source Translate(Vector2) Translates the transform by the specified offset. Declaration public void Translate(Vector2 Offset) Parameters Type Name Description Vector2 Offset The offset as a Vector2. | Edit this page View Source Translate((float, float)) Translates the transform by the specified offset. Declaration public void Translate((float, float) Offset) Parameters Type Name Description (float, float) Offset The offset as a tuple(float, float)"
  },
  "api/RayGame.html": {
    "href": "api/RayGame.html",
    "title": "Namespace RayGame",
    "keywords": "Namespace RayGame Classes CollisionDetection Provides a method for collision detection between shapes. Engine The main engine class that initializes and runs the game. GameObject Represents a game object in the Scene. Mesh Represents a 2D mesh consisting of a collection of vertices. MeshRenderer A Renderer that renders a Mesh associated with a GameObject. SpriteRenderer Transform The class that holds all the transformation data for an object Interfaces IGameComponent Interface for game components. IRenderer Interface for renderers."
  },
  "docs/Components.html": {
    "href": "docs/Components.html",
    "title": "Logic",
    "keywords": "Logic Think of Components as scripts that you attach to a GameObject to add logic to what it does. There are no restrictions about how many components a GameObject has, or how many GameObjects have the same component. However, always keep in mind, that a GameObject can only have 1 type of component at a time, so write your logic accordingly. It is not possible to add the same component to a GameObject multiple times. The Component Script Lets start talking about components. There can be only 1 of them on a Gameobject They must implement the \"IGameComponent\" Interface They Must have a Container variable It must have a Start() and Update() method. using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } public void Start() { } public void Update() { } } I have created a Main class to be my component. This is what an Empty Component script would look like. Notice how it Implements IGameComponent If your IDE supports it, then just by typing the name of the variable or method, A suggestion will show up to autocomplete the entire sentence. The Container variable is the reference you will use to reffer to your GameObject that component to attached to. With that said, lets add some simple code: using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } public void Start() { Console.WriteLine(\"Hello Component!\"); } public void Update() { } } And with that, we finally have our Component Script done. Lets put this all together! Running the Engine Now we have both an Entry Script, and a Component to use, lets finally have something we can see. In our Entry script, lets now use our \"Main\" Component in the INIT function: using RayGame; using [YOUR_NAMESPACE];; public class Entry { public static void Main() { Console.WriteLine(\"Hello World\"); Engine.INIT<Main>(); } } And with this, your window has opened up and your cosole should be showing: Hello World Hello Component!"
  },
  "docs/Getting_Started.html": {
    "href": "docs/Getting_Started.html",
    "title": "Hello World!",
    "keywords": "Hello World! Note: Now that we finally have our project setup, lets begin writing some code!. Now, we would need 2 scripts to start with. A Entry script, and a Component to start everything else. Create a new folder if you want, organising files will be really helpful in the long run. The Entry script When using this engine, we need some entry point to tell the Engine to start, thats what this script is for. So lets make a script called Entry.cs When using the engine, make sure to include: using RayGame; This is the Engine code that we have imported to start making something. After that, lets create a very standard C# script: using RayGame; using [YOUR_NAMESPACE];; public class Entry { public static void Main() { Console.WriteLine(\"Hello World\"); //Note, the file does not HAVE to called Entry. } } Lovely, we now have a script that we can use as an entry, from here we can initiate the Engine to start doing what we want it to do. Via the Engine Class, we Run an INIT function to attach a Component of choice into a prebuilt GameObject that we then use to manipulate the Engine to do what we want. Although that may seem complicated, dont worry, it will be explained. Engine.INIT<T>(); As you can see, the INIT function requires some class to replace its Template field. That class is going to be our Custom Component. In the next section, we will talk about Components, and finally get something to show!"
  },
  "docs/Hello_Square.html": {
    "href": "docs/Hello_Square.html",
    "title": "A GameObject",
    "keywords": "A GameObject Now that we have all this setup, we can completely forget about our Entry Script. We not only consider our Main Class as the point where the Engine Starts. Keeping that in Mind, let me walk you through making a simple square, so that you understand how to write logic. Creating a GameObject Creating a GameObject is pretty simple. A lot of your required functions can be found in the Engine Class. So we use that to create a GameObject. var square = Engine.CreateGameObject(\"My Square\"); Here we use the Engine add GameObject to the scene. Most functions that involve GameObjects in the scene will be done through the Engine Class. We dont absolutely need to assign the GameObject to a variable, but if you want to, you can After that, we can now set the position of the Object. square.Transform.Position = new Vector2(400, 240); The GameObject has a transform, which we manipulate the Position property to assign a new position. In Raylib, the top left is (0,0), hence, (400,240) would be the middle of the window. Despite assigning a position though, you still cannot see anything when you run the project. Thats because tou have not assigned a Renderer to the GameObject. Now, GameObjects have a LOT of methods and some properties you can mess around with, but we shall not be covering all of them right now. Renderer So, the answer seems simple right? Just add a renderer to the Object, and you can see it. But no, there a just a few more steps before you get there. Lets start with adding a Renderer. square.AddRenderer<MeshRenderer>(); And that how we add a Mesh Renderer to the GameObject. GAMEOBJECT.AddRenderer<T>(); GAMEOBJECT.AddComponent<T>(); These are the methods that can add Components and Renderers to your GameObject, allowing you to create more complex activity in your scene. Now that we have a Renderer, we need to tell it what to render. Meshes A Mesh is a class that stores vertices of a shape. It contains some methods that let you then manipulate the shape it contains. All the points of the Mesh are completely local, so you dont need to break your head trying to figure out where you should place each point. (i mean, you still do, but not that much). Mesh sqr = new Mesh(new[] {(10f, 10f), (-10f, 10f), (-10f, -10f), (-10f, -10f)}); I have constructed a Mesh, that takes in an Array of either tuple(float, float), or an array of Vector2. The Choice of types are up to you. Putting it all Together Finally, now that we have eveything setup, lets take a look at the final code: using System.Numerics; using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } public void Start() { Console.WriteLine(\"Hello Component!\"); var square =Engine.CreateGameObject(\"My Square\"); square.Transform.Position = new Vector2(400, 240); Mesh sqr = new Mesh(new[] {(10f, 10f), (-10f, 10f), (-10f, -10f), (10f, -10f)}); MeshRenderer Renderer = square.AddRenderer<MeshRenderer>(); Renderer.SetMesh(sqr); } public void Update() { } } And Voilà! Your code now generates a square. Adding some Features Now that we have a square, it seems a bit too small, so lets make the square bigger Lets also make the square rotate a little per frame. square.Transform.Scale = 4.5f; square.Transform.Rotate(2); I have moved the variable as a global one, to be used in other functions. I have called rotate in update, and changed the scale in start. using System.Numerics; using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } private GameObject square; public void Start() { Console.WriteLine(\"Hello Component!\"); square = Engine.CreateGameObject(\"My Square\"); square.Transform.Position = new Vector2(400, 240); Mesh sqr = new Mesh(new[] { (10f, 10f), (-10f, 10f), (-10f, -10f), (10f, -10f) }); MeshRenderer Renderer = square.AddRenderer<MeshRenderer>(); Renderer.SetMesh(sqr); square.Transform.Scale = 4.5f; } public void Update() { square.Transform.Rotate(2); } }"
  },
  "docs/Installation.html": {
    "href": "docs/Installation.html",
    "title": "Installation",
    "keywords": "Installation This Game Engine/FrameWork was written in C#, with no GUI whatsoever to aid in modification or visually representing your work. Hence, It is required to use an IDE of some kind to write your code. The IDE This Engine was developed on the Rider IDE, and so this page will you Rider as its source of reference. However, Visual Studio is also a powerfull IDE for C# and C++, and as long as you can understand the Docs, and do some basic googling, you should also be able to get the Engine Running. Make sure you have Dotnet 7.0 or above installed. Open your IDE, and made a dedicated Project to start making your game. The Dependencies Go to Release and download the latest release for the DLL required. In the Project, Open up the dedicated Nugget tab and install RayLib_cs(6.0.0). Incase you cannot use the inbuilt solution, you can try the command line here In your dedicated IDE, Put the RayGame.dll in your local directory, and setup a reference to it. In Rider, right - click the project, click Add, Add reference and browse to add the dll. And there you go! You can now start Making your game!"
  },
  "docs/Opts.html": {
    "href": "docs/Opts.html",
    "title": "Optimisations and Efficiency",
    "keywords": "Optimisations and Efficiency Along with what i have shown you, there are other features like collision, that you need to find and learn by yourself. You can do that by checking out the API section next to the Docs that you are reading. In said API, all Classes and methods have a an option to View Source next to it, clicking it will take you to the source code for said Class/ Method. The Plethora of methods available should let you do a variety of things, and i am open to adding more if requested. That being said, I have made a very basic version of Flappy bird, which you can check out by doing Engine.INIT<RayGame.Demo.Manager>(); New Code After refining the code made earlier, this is what it looks like now: using System.Numerics; using RayGame; namespace TestEngine; public class Main : IGameComponent { public GameObject Container { get; set; } private GameObject square; public void Start() { square = Engine.CreateGameObject(\"My Square\", new Transform( new Vector2(400, 240), 0, 4.5f)); square.AddRenderer<MeshRenderer>().SetMesh( new Mesh(new[] { (10f, 10f), (-10f, 10f), (-10f, -10f), (10f, -10f) })); // Code has been expanded with \\n so that its more readable. } public void Update() { square.Transform.Rotate(2); } } With the Help of different constructor, chaining, and declaring a variable inside a constructor, we have made the same program with less clutter. technically, I could chain the AddRenderer<>() to the CreateGameObject(), but I decided not to. And that marks the END of this tutorial, from here, you can read the docs and try making your own stuff!"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to RayEngine.",
    "keywords": "Welcome to RayEngine. This is a project i made because i was bored. Inspired by many others, i decided to try to make something kind of like an intermediate between pure graphics, and a completely abstracted engine. Hence the birth of RayEngine. The Idea: By opting RayLib as the backend, i decided to build my Engine/Framework. Luckily, Raylib has a special repository called RayLib_cs, created specifically to create bindings for the C# programming Language. So after a lot of Reading, and writing code, i finally finished what is arguably 1.0 of the RayEngine.Opting for inspiration from the Unity Engine, and writing a lot of code to abstract away all the RayLib, into my framwork that is very Object orientated in nature. To the side, you can find the dedicated Documentation as well as API, Good Luck! Chao!"
  },
  "templates/SingulinkFX-3.0.2/README.html": {
    "href": "templates/SingulinkFX-3.0.2/README.html",
    "title": "SingulinkFX",
    "keywords": "SingulinkFX SingulinkFX is a fully responsive DocFX template used for Singulink projects to produce documentation that is familiar to those used to browsing Microsoft's .NET documentation. Features: Responsive layout for all device sizes. Easily configurable colors and sidebar width. Empty table columns are removed, so if you don't comment the parameters or return value on some methods then it won't display an empty description column. The table of contents supports 4 levels of items to properly facilitate usage together with the separatePages member layout. Contains optional style overrides optimized for displaying articles. Includes Bootstrap Icons. Live Demo (Singulink.IO.FileSystem) About Singulink We are a small team of engineers and designers dedicated to building beautiful, functional and well-engineered software solutions. We offer very competitive rates as well as fixed-price contracts and welcome inquiries to discuss any custom development / project support needs you may have. Visit https://github.com/Singulink to see our full list of publicly available libraries and other open-source projects. Installation Download the source or the zipped file from the releases page. In your DocFX project folder, create a directory named templates, if it doesn't already exist. Copy the singulinkfx folder from this repository into the templates folder. In your docfx.json configuration file, add the singulinkfx path into the build.template property: \"template\": [\"default\", \"templates/singulinkfx\"] A real-world example of a .NET library using this template with articles can be found in the Singulink.IO.FileSystem repository (check out the Docs folder). If you are new to DocFX you might also find it helpful for properly setting up the table of contents. Versions and Upgrading Version 3.x For use with DocFX v2.75 and above. Version 2.x For use with DocFX v2.62 and above. The memberpage-extras plugin has been removed for version 2+ of the template. DocFX v2.62 no longer shows explicit interface members by default. Furthermore, the functionality to group explicit interface implementations into their own section in the table of contents has been merged into the DocFX codebase and an option for including explicit interface implementations is in the works so the plugin should no longer be necessary moving forward. Version 1.x For DocFX versions older than v2.62 you should use v1.1 of this template. Customization Configuration The following is a sample docfx.json global metadata section that demonstrates the usage of the options this theme offers: \"globalMetadata\": { \"_appTitle\": \"Singulink.IO.FileSystem\", \"_appName\": \"File System\", \"_appFaviconPath\": \"images/favicon.png\", \"_appLogoPath\": \"images/logo.png\", \"_appFooter\": \"<strong>DocFX + Singulink = ♥</strong>\", \"_copyrightFooter\": \"© Singulink. All rights reserved.\", \"_enableSearch\": true, \"_disableSideFilter\": false, \"_enableNewTab\": true, \"_disableContribution\": false, \"_disableBreadcrumb\": false, } Colors and Layout You can change any color as well as the width of the side bar and font sizes for desktop and mobile views. The values are defined in the styles/config.css file. The recommended approach to changing the default values is to create another directory inside templates for your sub-theme that overrides these values in a styles/main.css file, and add your theme to the end of the list of templates in docfx.json. Your main.css file will be automatically referenced in the output, there is no need to override any other template files. Custom Javascript The styles/main.js file can be used to add your own custom Javascript. The recommended approach is to create another directory inside templates for your sub-theme, add a styles/main.js file, and add your theme to the end of the list of templates in docfx.json. Your main.js file will be automatically referenced in the output, there is no need to override any other template files. Article Styling Wrap your HTML or markdown in a <div class=\"article\"></div> to activate styles that change heading styles and spacing to something more suitable for articles instead of API member docs. Supports up to 5 heading levels (h1 to h5 for HTML or # to ##### for markdown). More Screenshots Desktop Mobile Attribution Special thanks to @jbltx for creating DiscordFX which was a great starting point for this template."
  }
}