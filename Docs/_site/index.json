{
  "api/RayGame.CollisionDetection.html": {
    "href": "api/RayGame.CollisionDetection.html",
    "title": "Class CollisionDetection",
    "keywords": "Class CollisionDetection Namespace RayGame Assembly RayGame.dll Provides a method for collision detection between shapes. public static class CollisionDetection Inheritance object CollisionDetection Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This is a Static class used internally to check the collision between Colliders in GameObjects.Primarily for internal use Methods CheckCollision(Vector2[], Vector2[]) Checks if two shapes are colliding. public static bool CheckCollision(Vector2[] shape1, Vector2[] shape2) Parameters shape1 Vector2[] The first shape. shape2 Vector2[] The second shape. Returns bool True if the shapes are colliding, otherwise false."
  },
  "api/RayGame.Demo.Demo.html": {
    "href": "api/RayGame.Demo.Demo.html",
    "title": "Class Demo",
    "keywords": "Class Demo Namespace RayGame.Demo Assembly RayGame.dll public static class Demo Inheritance object Demo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Main() public static void Main()"
  },
  "api/RayGame.Demo.Manager.html": {
    "href": "api/RayGame.Demo.Manager.html",
    "title": "Class Manager",
    "keywords": "Class Manager Namespace RayGame.Demo Assembly RayGame.dll public class Manager : IGameComponent Inheritance object Manager Implements IGameComponent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PipeInstances public List<GameObject> PipeInstances Field Value List<GameObject> Running public bool Running Field Value bool Properties Container The container GameObject for this component. public GameObject Container { get; set; } Property Value GameObject Instance public static Manager Instance { get; } Property Value Manager Methods RestartGame() public void RestartGame() SpawnObject() public void SpawnObject() Start() Called when the component is Added. public void Start() Update() Called every frame to update the component. public void Update()"
  },
  "api/RayGame.Demo.bird.html": {
    "href": "api/RayGame.Demo.bird.html",
    "title": "Class Bird",
    "keywords": "Class Bird Namespace RayGame.Demo Assembly RayGame.dll public class Bird : IGameComponent Inheritance object Bird Implements IGameComponent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Container The container GameObject for this component. public GameObject Container { get; set; } Property Value GameObject Methods Start() Called when the component is Added. public void Start() Update() Called every frame to update the component. public void Update()"
  },
  "api/RayGame.Demo.html": {
    "href": "api/RayGame.Demo.html",
    "title": "Namespace RayGame.Demo",
    "keywords": "Namespace RayGame.Demo Classes Bird Demo Manager"
  },
  "api/RayGame.Engine.html": {
    "href": "api/RayGame.Engine.html",
    "title": "Class Engine",
    "keywords": "Class Engine Namespace RayGame Assembly RayGame.dll The main engine class that initializes and runs the game. public static class Engine Inheritance object Engine Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields random The Random Number Generator initiated with the Engine. public static Random random Field Value Random Properties GAMETIME The value associated with the amount of milliseconds passed. public static long GAMETIME { get; } Property Value long Methods CreateGameObject(string) Creates a new game object with the specified name. public static GameObject CreateGameObject(string name) Parameters name string The name of the game object. Returns GameObject The created game object. CreateGameObject(string, Transform) Creates a new game object with the specified name and Transform>. public static GameObject CreateGameObject(string name, Transform transform) Parameters name string The name of the game object. transform Transform The transform of the game object. Returns GameObject The created game object. CreateGameObject(string, Vector2, float, float) Creates a new game object with the specified name, position, angle, and scale. public static GameObject CreateGameObject(string name, Vector2 Position, float Angle, float Scale) Parameters name string The name of the game object. Position Vector2 The position of the game object. Angle float The angle of the game object. Scale float The scale of the game object. Returns GameObject The created game object. DeleteGameObject(GameObject) Deletes the specified game object. public static void DeleteGameObject(GameObject Gobj) Parameters Gobj GameObject The game object to delete. DisableColliderRendering() Disables rendering of colliders for all game objects. Look at GameObject for more detail. public static void DisableColliderRendering() EnableColliderRendering() Enables rendering of colliders for all game objects. Look at GameObject for more detail. public static void EnableColliderRendering() FindObjectByName(string) Finds a game object by its name. public static GameObject FindObjectByName(string name) Parameters name string The name of the game object. Returns GameObject The game object with the specified name, or null if not found. FindObjectOfType<T>() Finds the first game object that has a component of the specified type. public static GameObject FindObjectOfType<T>() Returns GameObject The game object with the specified component, or null if not found. Type Parameters T The type of component to look for. GetGameObjectCount() Gets the count of game objects currently in the engine. public static int GetGameObjectCount() Returns int The number of game objects. INIT<T>() Initializes the game engine with a specified game component. That Custom Component is the entry point into using the Engine. public static void INIT<T>() where T : IGameComponent, new() Type Parameters T The type of game component to initialize."
  },
  "api/RayGame.GameObject.html": {
    "href": "api/RayGame.GameObject.html",
    "title": "Class GameObject",
    "keywords": "Class GameObject Namespace RayGame Assembly RayGame.dll Represents a game object in the Scene. public class GameObject Inheritance object GameObject Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The GameObjects are the building blocks of your scene. They contain a few fields that allow for adding logic and properties to make them functional. Fields Colliders The List of Colliders attached to the GameObject. They are represented as a List of Mesh's. You can add Colliders directly. public List<Mesh> Colliders Field Value List<Mesh> DEBUGCOLIDERS This is a property of the GameObject that determines what is to be rendered. If false, all the IRenderer's Update Method will be fired per frame. If true, then instead of the IRenderer's, the Colliders attached to your GameObject will be rendered. This is for debugging purposes. public bool DEBUGCOLIDERS Field Value bool Name This is the Name Associated with the GameObject public string Name Field Value string Transform This is the Transform attached to the GameObject. public Transform Transform Field Value Transform Methods AddComponent<T>() Adds a component of the specified type to this game object. public T AddComponent<T>() where T : IGameComponent, new() Returns T The added component. Type Parameters T The type of component to add. AddRenderer<T>() Adds a renderer of the specified type to this game object. public T AddRenderer<T>() where T : IRenderer, new() Returns T The added renderer. Type Parameters T The type of renderer to add. DeleteAllRenderers() Deletes all renderers from this game object. public void DeleteAllRenderers() DeleteComponent<T>() Deletes the first component of the specified type from this game object. public void DeleteComponent<T>() where T : IGameComponent Type Parameters T The type of component to delete. DeleteObjectComponents() Deletes all components from this game object. public void DeleteObjectComponents() DeleteRenderer<T>(int) Deletes a renderer of the specified type at the given index from this game object. public void DeleteRenderer<T>(int Index) where T : class, IRenderer Parameters Index int The index of the renderer to delete. Type Parameters T The type of renderer to delete. GetComponentNameList(bool) Gets a list of the names of all components attached to this game object. public List<string> GetComponentNameList(bool Print) Parameters Print bool If true, prints the names to the console. Returns List<string> A list of component names. GetComponent<T>() Gets the first component of the specified type attached to this game object. public T GetComponent<T>() Returns T The component if found, otherwise null. Type Parameters T The type of component to get. GetRendererNameList(bool) Gets a list of the names of all renderers attached to this game object. public List<string> GetRendererNameList(bool Print) Parameters Print bool If true, prints the names to the console. Returns List<string> A list of renderer names. GetRenderer<T>(int) Gets a renderer of the specified type at the given index from this game object. If the GameObject contains multiple types of renderers, then the index takes into account only the specified T public T GetRenderer<T>(int Index) where T : class, IRenderer Parameters Index int The index of the renderer to get. Returns T The renderer if found, otherwise null. Type Parameters T The type of renderer to get. HasComponent<T>() Checks if this game object has a component of the specified type. public bool HasComponent<T>() where T : IGameComponent Returns bool True if the component is found, otherwise false. Type Parameters T The type of component to check for. HasRenderer<T>() Checks if this game object has a renderer of the specified type. public bool HasRenderer<T>() where T : IRenderer Returns bool True if the renderer is found, otherwise false. Type Parameters T The type of renderer to check for. IsColliding(GameObject) Checks if this game object is colliding with the specified target game object. public bool IsColliding(GameObject Target) Parameters Target GameObject The target game object to check for collisions with. Returns bool True if a collision is detected, otherwise false. SetTransform(Transform) Sets the transform of this game object to the specified new transform. public void SetTransform(Transform newTransform) Parameters newTransform Transform The new transform to set. ShiftComponent<T>(int) Shifts a component of the specified type by a given offset in the component list. public void ShiftComponent<T>(int offset) where T : IGameComponent Parameters offset int The offset by which to shift the component. Type Parameters T The type of component to shift. ShiftRenderer<T>(int) Shifts a renderer of the specified type by a given offset in the renderer list. public void ShiftRenderer<T>(int offset) where T : IRenderer Parameters offset int The offset by which to shift the renderer. Type Parameters T The type of renderer to shift. StartActions() The function that is called when the GameObject is Initiated. Not used in most cases. Primarily for internal use public void StartActions() UpdateActions() This is the function that calls to update the state of the GameObject per frame.Primarily for internal use public void UpdateActions()"
  },
  "api/RayGame.IGameComponent.html": {
    "href": "api/RayGame.IGameComponent.html",
    "title": "Interface IGameComponent",
    "keywords": "Interface IGameComponent Namespace RayGame Assembly RayGame.dll Interface for game components. public interface IGameComponent Remarks Implement this interface to create custom game components. Each GameObject has a List of Components that it runs by itself. Hence, any class that implements IGameComponent, will be eligible to perform as a script attached to the Object. By This, It is possible to create Prefabs buy creating 1 class component that adds all the required components and modifications. Properties Container The container GameObject for this component. GameObject Container { get; set; } Property Value GameObject Methods Start() Called when the component is Added. void Start() Update() Called every frame to update the component. void Update()"
  },
  "api/RayGame.IRenderer.html": {
    "href": "api/RayGame.IRenderer.html",
    "title": "Interface IRenderer",
    "keywords": "Interface IRenderer Namespace RayGame Assembly RayGame.dll Interface for renderers. public interface IRenderer Remarks This is interface is to be inherited by all Renderers, If you wish to make a custom renderer, then u can, but i would recommend sticking to the provided renderers. Primarily for internal use Properties Container The container GameObject for this renderer. Any Actions that want to be performed to it, is does through this reference. GameObject Container { get; set; } Property Value GameObject Methods Start() The Function Called when the Renderer is Added to an Object. void Start() Update() Called every frame to update the renderer. Primarily holds code to render the content. void Update()"
  },
  "api/RayGame.Mesh.html": {
    "href": "api/RayGame.Mesh.html",
    "title": "Class Mesh",
    "keywords": "Class Mesh Namespace RayGame Assembly RayGame.dll Represents a 2D mesh consisting of a collection of vertices. public class Mesh Inheritance object Mesh Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks A Mesh is a collection of Vertices that is used to display/render anything. It is always a closed loop. The Mesh also have functions that can edit it, however, be careful, as all modifications as permanent. It is Attached to a MeshRenderer to be viewed at the GameObject's Position. The vertices themselves are always represented in local space. Constructors Mesh(Vector2[]) Initializes a new instance of the Mesh class with an array of vertices specified as Vector2. public Mesh(Vector2[] vertexArray) Parameters vertexArray Vector2[] An array of Vector2 representing the vertices of the mesh. Mesh((float, float)[]) Initializes a new instance of the Mesh class with an array of vertices specified as tuples. public Mesh((float, float)[] vertexArray) Parameters vertexArray (float, float)[] An array of tuples representing the vertices of the mesh. Methods AddVertex(Vector2) Adds a single vertex to the mesh. public void AddVertex(Vector2 vertex) Parameters vertex Vector2 The vertex to add to the mesh. AddVertex((float, float)) Adds a single vertex to the mesh specified as a tuple. public void AddVertex((float, float) vertex) Parameters vertex (float, float) The vertex to add to the mesh. AddVertices(Vector2[]) Adds an array of vertices to the mesh. public void AddVertices(Vector2[] vertexArray) Parameters vertexArray Vector2[] An array of Vector2 to add to the mesh. AddVertices((float, float)[]) Adds an array of vertices to the mesh specified as tuples. public void AddVertices((float, float)[] vertexArray) Parameters vertexArray (float, float)[] An array of tuples representing the vertices to add to the mesh. DeleteLastVertex() Deletes a Vertex from the last position. public void DeleteLastVertex() DeleteVertex(int) Deletes a vertex at the specified index. public void DeleteVertex(int Index) Parameters Index int The index of the vertex to delete. DeleteVertex((float, float)) Deletes a vertex that matches the specified point. public void DeleteVertex((float, float) point) Parameters point (float, float) The point representing the vertex to delete. GetVertexArray() Gets the vertices of the mesh as an array. public Vector2[] GetVertexArray() Returns Vector2[] An array of Vector2 representing the vertices of the mesh. InsertVertex(int, Vector2) Inserts a vertex at the specified index. public void InsertVertex(int Index, Vector2 Vertex) Parameters Index int The index at which to insert the vertex. Vertex Vector2 The vertex to insert. RotateMesh(float) Rotates the entire mesh by the specified angle. public Mesh RotateMesh(float Angle) Parameters Angle float The angle in degrees by which to rotate the mesh. Returns Mesh The rotated mesh. ScaleMesh(float) Scales the entire mesh by the specified scale factor. public Mesh ScaleMesh(float Scale) Parameters Scale float The scale factor by which to scale the mesh. Returns Mesh The scaled mesh. ShiftMesh(Vector2) Shifts the entire mesh by the specified offset in Position. public Mesh ShiftMesh(Vector2 Offset) Parameters Offset Vector2 The offset by which to shift the mesh. Returns Mesh The shifted mesh. ShiftMesh((float, float)) Shifts the entire mesh by the specified offset in Position. public Mesh ShiftMesh((float, float) Offset) Parameters Offset (float, float) The offset specified as a tuple by which to shift the mesh. Returns Mesh The shifted mesh."
  },
  "api/RayGame.MeshRenderer.html": {
    "href": "api/RayGame.MeshRenderer.html",
    "title": "Class MeshRenderer",
    "keywords": "Class MeshRenderer Namespace RayGame Assembly RayGame.dll A Renderer that renders a Mesh associated with a GameObject. public class MeshRenderer : IRenderer Inheritance object MeshRenderer Implements IRenderer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Container The Container is the reference to the GameObject it is connected to. public GameObject Container { get; set; } Property Value GameObject Methods GetMesh() Gets the mesh being rendered. public Mesh GetMesh() Returns Mesh The Mesh being rendered. RenderMesh(Vector2[], Color) Renders the specified vertices as lines with the given color. Primarily for internal use public static void RenderMesh(Vector2[] Vertices, Color color) Parameters Vertices Vector2[] An array of Vector2 representing the vertices of the mesh. color Color The color to use for rendering the lines. SetMesh(Mesh) Sets the mesh to be rendered. public Mesh SetMesh(Mesh mesh) Parameters mesh Mesh The Mesh to set. Returns Mesh The Mesh that was set. Start() Initializes the renderer. This method is called when the renderer is first added to a GameObject. public void Start() Update() Updates the renderer. This method is called once per frame. public void Update()"
  },
  "api/RayGame.Transform.html": {
    "href": "api/RayGame.Transform.html",
    "title": "Class Transform",
    "keywords": "Class Transform Namespace RayGame Assembly RayGame.dll The class that holds all the transformation data for an object public class Transform Inheritance object Transform Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks A Class that is used to represent the Position, Rotation and Scale of an object. This class super-imposes its properties onto vertices per frame, which means that any object containing this class can enact global transformations within that GameObject. By default, any transformations does on the object should be done through its Transform. Constructors Transform() Initializes a new instance of the Transform class with default values. Position being (0,0). Rotation being 0. Scale being 1. public Transform() Transform(Vector2, float, float) Initializes a new instance of the Transform class with specified position, rotation, and scale. public Transform(Vector2 pos, float ang, float sc) Parameters pos Vector2 The position of the transform. ang float The rotation of the transform in degrees. sc float The scale of the transform. Fields Position The position of the transform as a Vector2. public Vector2 Position Field Value Vector2 Scale The Scale of the transform as a Float. public float Scale Field Value float Methods ApplyTransform(Vector2[]) Applies the transform to an array of vertices. Applies that transforms onto the Vertices of a Mesh's Vertex Array. Primarily used internally in the Engine. public Vector2[] ApplyTransform(Vector2[] VertexArray) Parameters VertexArray Vector2[] The array of vertices to transform. Returns Vector2[] The transformed array of vertices. GetRotation() Gets the rotation of the transform. public float GetRotation() Returns float The rotation in returned as Degrees. Rotate(float) Rotates the transform by the specified angle. Takes an Angle in degrees, and stores them internally as radians. public void Rotate(float Angle) Parameters Angle float The angle in degrees. SetRotation(float) Sets the rotation of the transform to the specified angle. Takes an Angle in degrees, and stores them internally as radians. public void SetRotation(float Angle) Parameters Angle float The angle in degrees. Translate(Vector2) Translates the transform by the specified offset. public void Translate(Vector2 Offset) Parameters Offset Vector2 The offset as a Vector2. Translate((float, float)) Translates the transform by the specified offset. public void Translate((float, float) Offset) Parameters Offset (float, float) The offset as a tuple(float, float)"
  },
  "api/RayGame.html": {
    "href": "api/RayGame.html",
    "title": "Namespace RayGame",
    "keywords": "Namespace RayGame Classes CollisionDetection Provides a method for collision detection between shapes. Engine The main engine class that initializes and runs the game. GameObject Represents a game object in the Scene. Mesh Represents a 2D mesh consisting of a collection of vertices. MeshRenderer A Renderer that renders a Mesh associated with a GameObject. Transform The class that holds all the transformation data for an object Interfaces IGameComponent Interface for game components. IRenderer Interface for renderers."
  },
  "docs/Components.html": {
    "href": "docs/Components.html",
    "title": "Logic",
    "keywords": "Logic Think of Components as scripts that you attach to a GameObject to add logic to what it does. There are no restrictions about how many components a GameObject has, or how many GameObjects have the same component. However, always keep in mind, that a GameObject can only have 1 type of component at a time, so write your logic accordingly. It is not possible to add the same component to a GameObject multiple times. The Component Script Lets start talking about components. There can be only 1 of them on a Gameobject They must implement the \"IGameComponent\" Interface They Must have a Container variable It must have a Start() and Update() method. using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } public void Start() { } public void Update() { } } I have created a Main class to be my component. This is what an Empty Component script would look like. Notice how it Implements IGameComponent If your IDE supports it, then just by typing the name of the variable or method, A suggestion will show up to autocomplete the entire sentence. The Container variable is the reference you will use to reffer to your GameObject that component to attached to. With that said, lets add some simple code: using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } public void Start() { Console.WriteLine(\"Hello Component!\"); } public void Update() { } } And with that, we finally have our Component Script done. Lets put this all together! Running the Engine Now we have both an Entry Script, and a Component to use, lets finally have something we can see. In our Entry script, lets now use our \"Main\" Component in the INIT function: using RayGame; using [YOUR_NAMESPACE];; public class Entry { public static void Main() { Console.WriteLine(\"Hello World\"); Engine.INIT<Main>(); } } And with this, your window has opened up and your cosole should be showing: Hello World Hello Component!"
  },
  "docs/Getting_Started.html": {
    "href": "docs/Getting_Started.html",
    "title": "Hello World!",
    "keywords": "Hello World! Note: Now that we finally have our project setup, lets begin writing some code!. Now, we would need 2 scripts to start with. A Entry script, and a Component to start everything else. Create a new folder if you want, organising files will be really helpful in the long run. The Entry script When using this engine, we need some entry point to tell the Engine to start, thats what this script is for. So lets make a script called Entry.cs When using the engine, make sure to include: using RayGame; This is the Engine code that we have imported to start making something. After that, lets create a very standard C# script: using RayGame; using [YOUR_NAMESPACE];; public class Entry { public static void Main() { Console.WriteLine(\"Hello World\"); //Note, the file does not HAVE to called Entry. } } Lovely, we now have a script that we can use as an entry, from here we can initiate the Engine to start doing what we want it to do. Via the Engine Class, we Run an INIT function to attach a Component of choice into a prebuilt GameObject that we then use to manipulate the Engine to do what we want. Although that may seem complicated, dont worry, it will be explained. Engine.INIT<T>(); As you can see, the INIT function requires some class to replace its Template field. That class is going to be our Custom Component. In the next section, we will talk about Components, and finally get something to show!"
  },
  "docs/Hello_Square.html": {
    "href": "docs/Hello_Square.html",
    "title": "A GameObject",
    "keywords": "A GameObject Now that we have all this setup, we can completely forget about our Entry Script. We not only consider our Main Class as the point where the Engine Starts. Keeping that in Mind, let me walk you through making a simple square, so that you understand how to write logic. Creating a GameObject Creating a GameObject is pretty simple. A lot of your required functions can be found in the Engine Class. So we use that to create a GameObject. var square = Engine.CreateGameObject(\"My Square\"); Here we use the Engine add GameObject to the scene. Most functions that involve GameObjects in the scene will be done through the Engine Class. We dont absolutely need to assign the GameObject to a variable, but if you want to, you can After that, we can now set the position of the Object. square.Transform.Position = new Vector2(400, 240); The GameObject has a transform, which we manipulate the Position property to assign a new position. In Raylib, the top left is (0,0), hence, (400,240) would be the middle of the window. Despite assigning a position though, you still cannot see anything when you run the project. Thats because tou have not assigned a Renderer to the GameObject. Now, GameObjects have a LOT of methods and some properties you can mess around with, but we shall not be covering all of them right now. Renderer So, the answer seems simple right? Just add a renderer to the Object, and you can see it. But no, there a just a few more steps before you get there. Lets start with adding a Renderer. square.AddRenderer<MeshRenderer>(); And that how we add a Mesh Renderer to the GameObject. GAMEOBJECT.AddRenderer<T>(); GAMEOBJECT.AddComponent<T>(); These are the methods that can add Components and Renderers to your GameObject, allowing you to create more complex activity in your scene. Now that we have a Renderer, we need to tell it what to render. Meshes A Mesh is a class that stores vertices of a shape. It contains some methods that let you then manipulate the shape it contains. All the points of the Mesh are completely local, so you dont need to break your head trying to figure out where you should place each point. (i mean, you still do, but not that much). Mesh sqr = new Mesh(new[] {(10f, 10f), (-10f, 10f), (-10f, -10f), (-10f, -10f)}); I have constructed a Mesh, that takes in an Array of either tuple(float, float), or an array of Vector2. The Choice of types are up to you. Putting it all Together Finally, now that we have eveything setup, lets take a look at the final code: using System.Numerics; using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } public void Start() { Console.WriteLine(\"Hello Component!\"); var square =Engine.CreateGameObject(\"My Square\"); square.Transform.Position = new Vector2(400, 240); Mesh sqr = new Mesh(new[] {(10f, 10f), (-10f, 10f), (-10f, -10f), (10f, -10f)}); MeshRenderer Renderer = square.AddRenderer<MeshRenderer>(); Renderer.SetMesh(sqr); } public void Update() { } } And Voilà! Your code now generates a square. Adding some Features Now that we have a square, it seems a bit too small, so lets make the square bigger Lets also make the square rotate a little per frame. square.Transform.Scale = 4.5f; square.Transform.Rotate(2); I have moved the variable as a global one, to be used in other functions. I have called rotate in update, and changed the scale in start. using System.Numerics; using RayGame; namespace [YOUR_NAMESPACE]; public class Main : IGameComponent { public GameObject Container { get; set; } private GameObject square; public void Start() { Console.WriteLine(\"Hello Component!\"); square =Engine.CreateGameObject(\"My Square\"); square.Transform.Position = new Vector2(400, 240); Mesh sqr = new Mesh(new[] { (10f, 10f), (-10f, 10f), (-10f, -10f), (10f, -10f) }); MeshRenderer Renderer = square.AddRenderer<MeshRenderer>(); Renderer.SetMesh(sqr); square.Transform.Scale = 4.5f; } public void Update() { square.Transform.Rotate(2); } }"
  },
  "docs/Installation.html": {
    "href": "docs/Installation.html",
    "title": "Installation",
    "keywords": "Installation This Game Engine/FrameWork was written in C#, with no GUI whatsoever to aid in modification or visually representing your work. Hence, It is required to use an IDE of some kind to write your code. The IDE This Engine was developed on the Rider IDE, and so this page will you Rider as its source of reference. However, Visual Studio is also a powerfull IDE for C# and C++, and as long as you can understand the Docs, and do some basic googling, you should also be able to get the Engine Running. Make sure you have Dotnet 7.0 or above installed. Open your IDE, and made a dedicated Project to start making your game. The Dependencies Go to Release and download the latest release for the DLL required. In the Project, Open up the dedicated Nugget tab and install RayLib_cs(6.0.0). Incase you cannot use the inbuilt solution, you can try the command line here In your dedicated IDE, Put the RayGame.dll in your local directory, and setup a reference to it. In Rider, right - click the project, click Add, Add reference and browse to add the dll. And there you go! You can now start Making your game!"
  },
  "docs/Opts.html": {
    "href": "docs/Opts.html",
    "title": "Optimisations and Efficiency",
    "keywords": "Optimisations and Efficiency Along with what i have shown you, there are other features like collision, that you need to find and learn by yourself. You can do that by checking out the API section next to the Docs that you are reading. In said API, all Classes and methods have a </> next to it, clicking it will take you to the source code for said Class/ Method. The Plethora of methods available should let you do a variety of things, and i am open to adding more if requested. That being said, I have made a very basic version of Flappy bird, which you can check out by doing Engine.INIT<RayGame.Demo.Manager>(); New Code After refining the code made earlier, this is what it looks like now: using System.Numerics; using RayGame; namespace TestEngine; public class Main : IGameComponent { public GameObject Container { get; set; } private GameObject square; public void Start() { square = Engine.CreateGameObject(\"My Square\", new Transform( new Vector2(400, 240), 0, 4.5f)); square.AddRenderer<MeshRenderer>().SetMesh( new Mesh(new[] { (10f, 10f), (-10f, 10f), (-10f, -10f), (10f, -10f) })); // Code has been expanded with \\n so that its more readable. } public void Update() { square.Transform.Rotate(2); } } With the Help of different constructor, chaining, and declaring a variable inside a constructor, we have made the same program with less clutter. technically, I could chain the AddRenderer<>() to the CreateGameObject(), but I decided not to. And that marks the END of this tutorial, from here, you can read the docs and try making your own stuff!"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to RayEngine.",
    "keywords": "Welcome to RayEngine. This is a project i made because i was bored. Inspired by many others, i decided to try to make something kind of like an intermediate between pure graphics, and a completely abstracted engine. Hence the birth of RayEngine. The Idea: By opting RayLib as the backend, i decided to build my Engine/Framework. Luckily, Raylib has a special repository called RayLib_cs, created specifically to create bindings for the C# programming Language. So after a lot of Reading, and writing code, i finally finished what is arguably 1.0 of the RayEngine.Opting for inspiration from the Unity Engine, and writing a lot of code to abstract away all the RayLib, into my framwork that is very Object orientated in nature. Above you can find the Docs above, along with the API to reffer when developing games on this Engine. Chao!"
  }
}